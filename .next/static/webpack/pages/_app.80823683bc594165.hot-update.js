"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./Context/NFTMarketplaceContext.js":
/*!******************************************!*\
  !*** ./Context/NFTMarketplaceContext.js ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NFTMarketplaceContext: function() { return /* binding */ NFTMarketplaceContext; },\n/* harmony export */   NFTMarketplaceProvider: function() { return /* binding */ NFTMarketplaceProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var web3modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! web3modal */ \"./node_modules/web3modal/dist/index.js\");\n/* harmony import */ var web3modal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(web3modal__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ \"./Context/constants.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n//INTERNAL  IMPORT\n\n//---FETCHING SMART CONTRACT\nconst fetchContract = (signerOrProvider)=>new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(_constants__WEBPACK_IMPORTED_MODULE_4__.NFTMarketplaceAddress, _constants__WEBPACK_IMPORTED_MODULE_4__.NFTMarketplaceABI, signerOrProvider);\n//---CONNECTING WITH SMART CONTRACT\nconst connectingWithSmartContract = async ()=>{\n    try {\n        let contract;\n        if (window.ethereum) {\n            const web3Modal = new (web3modal__WEBPACK_IMPORTED_MODULE_2___default())();\n            const connection = await web3Modal.connect();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.BrowserProvider(connection);\n            const signer = await provider.getSigner();\n            contract = fetchContract(signer);\n        } else {\n            // Sử dụng một node Ethereum công khai ở đây, ví dụ: Infura, Alchemy, ...\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(\"https://eth-sepolia.g.alchemy.com/v2/ARDDq0zYTkXSYjFZIrXpMz-joq07xKOo\");\n            contract = fetchContract(provider);\n        }\n        return contract;\n    } catch (error) {\n        console.log(\"Something went wrong while connecting with contract\", error);\n        // Nếu có lỗi, khởi tạo contract với provider không đăng nhập\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(\"https://eth-sepolia.g.alchemy.com/v2/ARDDq0zYTkXSYjFZIrXpMz-joq07xKOo\");\n        const contract = fetchContract(provider);\n        return contract;\n    }\n};\nconst NFTMarketplaceContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext();\nconst NFTMarketplaceProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const titleData = \"Discover, collect, and sell NFTs\";\n    //------USESTAT\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [openError, setOpenError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentAccount, setCurrentAccount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [accountBalance, setAccountBalance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    //---CHECK IF WALLET IS CONNECTD\n    const checkIfWalletConnected = async ()=>{\n        try {\n            if (!window.ethereum) return setOpenError(true), setError(\"Install MetaMask\");\n            const accounts = await window.ethereum.request({\n                method: \"eth_accounts\"\n            });\n            if (accounts.length) {\n                setCurrentAccount(accounts[0]);\n                console.log(accounts[0]);\n            } else {\n                // setError(\"No Account Found\");\n                // setOpenError(true);\n                console.log(\"No account\");\n            }\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.BrowserProvider(window.ethereum);\n            const getBalance = await provider.getBalance(accounts[0]);\n            const bal = ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.formatEther(getBalance);\n            setAccountBalance(bal);\n        } catch (error) {\n            // setError(\"Something wrong while connecting to wallet\");\n            // setOpenError(true);\n            console.log(\"not connected\");\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        checkIfWalletConnected();\n    }, []);\n    const approveAllNFTs = async ()=>{\n        try {\n            const contract = await connectingWithSmartContract();\n            const data = await contract.fetchMyNFTs();\n            // Lấy danh sách tokenId\n            const tokenIds = data.map((nft)=>nft.tokenId.toString());\n            // Approve từng NFT\n            for (const tokenId of tokenIds){\n                const approvalTx = await contract.approve(contract.address, tokenId);\n                await approvalTx.wait();\n                console.log(\"Approved NFT with token ID ${tokenId}\");\n            }\n        } catch (error) {\n            console.error(\"Error approving NFTs:\", error);\n        }\n    };\n    //---CONNET WALLET FUNCTION\n    const connectWallet = async ()=>{\n        try {\n            if (!window.ethereum) return setOpenError(true), setError(\"Install MetaMask\");\n            const accounts = await window.ethereum.request({\n                method: \"eth_requestAccounts\"\n            });\n            console.log(accounts);\n            setCurrentAccount(accounts[0]);\n            // window.location.reload();\n            connectingWithSmartContract();\n            await approveAllNFTs();\n        } catch (error) {\n        // setError(\"Error while connecting to wallet\");\n        // setOpenError(true);\n        }\n    };\n    //---UPLOAD TO IPFS FUNCTION\n    const uploadToPinata = async (file)=>{\n        if (file) {\n            try {\n                const formData = new FormData();\n                formData.append(\"file\", file);\n                const response = await (0,axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n                    method: \"post\",\n                    url: \"https://api.pinata.cloud/pinning/pinFileToIPFS\",\n                    data: formData,\n                    headers: {\n                        pinata_api_key: \"d2c77a08f8de766632d0\",\n                        pinata_secret_api_key: \"\\n            9546cb69a8634229d95e750e526fedd14eeb7c8856c12e0ae9c4b1bd0e56744e\",\n                        \"Content-Type\": \"multipart/form-data\"\n                    }\n                });\n                const ImgHash = \"https://gateway.pinata.cloud/ipfs/\".concat(response.data.IpfsHash);\n                return ImgHash;\n            } catch (error) {\n                console.log(\"Unable to upload image to Pinata\");\n            }\n        }\n    };\n    //---CREATENFT FUNCTION\n    const createNFT = async (name, price, image, description, router)=>{\n        if (!name || !description || !price || !image) return setError(\"Data Is Missing\"), setOpenError(true);\n        const data = JSON.stringify({\n            name,\n            description,\n            image\n        });\n        try {\n            const response = await (0,axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n                method: \"POST\",\n                url: \"https://api.pinata.cloud/pinning/pinJSONToIPFS\",\n                data: data,\n                headers: {\n                    pinata_api_key: \"d2c77a08f8de766632d0\",\n                    pinata_secret_api_key: \"\\n          9546cb69a8634229d95e750e526fedd14eeb7c8856c12e0ae9c4b1bd0e56744e\",\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            const url = \"https://gateway.pinata.cloud/ipfs/\".concat(response.data.IpfsHash);\n            console.log(url);\n            await createSale(url, price);\n            router.push(\"/searchPage\");\n        } catch (error) {\n            setError(\"Error while creating NFT\");\n            setOpenError(true);\n        }\n    };\n    //--- createSale FUNCTION\n    const createSale = async (url, formInputPrice, isReselling, id)=>{\n        try {\n            console.log(url, formInputPrice, isReselling, id);\n            const price = ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.parseUnits(formInputPrice, \"ether\");\n            const contract = await connectingWithSmartContract();\n            const listingPrice = await contract.getListingPrice();\n            const transaction = !isReselling ? await contract.createToken(url, price, {\n                value: listingPrice.toString()\n            }) : await contract.resellToken(id, price, {\n                value: listingPrice.toString()\n            });\n            await transaction.wait();\n            console.log(transaction);\n        } catch (error) {\n            setError(\"error while creating sale\");\n            setOpenError(true);\n            console.log(error);\n        }\n    };\n    //--FETCHNFTS FUNCTION\n    const fetchNFTs = async ()=>{\n        try {\n            const contract = await connectingWithSmartContract();\n            const data = await contract.fetchMarketItems();\n            console.log(data);\n            const items = await Promise.all(data.map(async (param)=>{\n                let { tokenId, seller, owner, price: unformattedPrice } = param;\n                if (tokenId === 0) {\n                    // Bỏ qua tokenId không hợp lệ\n                    return null;\n                }\n                const tokenURI = await contract.tokenURI(tokenId);\n                const { data: { image, name, description } } = await axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(tokenURI, {});\n                const price = ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.formatUnits(unformattedPrice.toString(), \"ether\");\n                return {\n                    price,\n                    tokenId: tokenId.toString(),\n                    seller,\n                    owner,\n                    image,\n                    name,\n                    description,\n                    tokenURI\n                };\n            }));\n            return items;\n        // }\n        } catch (error) {\n            // setError(\"Error while fetching NFTS\");\n            // setOpenError(true);\n            console.log(error);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        fetchNFTs();\n    }, []);\n    //--FETCHING MY NFT OR LISTED NFTs\n    const fetchMyNFTsOrListedNFTs = async (type)=>{\n        try {\n            if (currentAccount) {\n                const contract = await connectingWithSmartContract();\n                const data = type == \"fetchItemsListed\" ? await contract.fetchItemsListed() : await contract.fetchMyNFTs();\n                const items = await Promise.all(data.map(async (param)=>{\n                    let { tokenId, seller, owner, price: unformattedPrice } = param;\n                    const tokenURI = await contract.tokenURI(tokenId);\n                    const { data: { image, name, description } } = await axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(tokenURI);\n                    const price = ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.formatUnits(unformattedPrice.toString(), \"ether\");\n                    return {\n                        price,\n                        tokenId: tokenId.toString(),\n                        seller,\n                        owner,\n                        image,\n                        name,\n                        description,\n                        tokenURI\n                    };\n                }));\n                return items;\n            }\n        } catch (error) {\n            console.log(error);\n        // setError(\"Error while fetching listed NFTs\");\n        // setOpenError(true);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        fetchMyNFTsOrListedNFTs();\n    }, []);\n    //---buy NFT\n    const buyNFT = async (nft)=>{\n        try {\n            const contract = await connectingWithSmartContract();\n            const price = ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.parseUnits(nft.price.toString(), \"ether\");\n            const transaction = await contract.createMarketSale(nft.tokenId, {\n                value: price\n            });\n            await transaction.wait();\n            router.push(\"/author\");\n        } catch (error) {\n            setError(\"Error While buying NFT\");\n            setOpenError(true);\n        }\n    };\n    // Delete NFT\n    const burnNFT = async (tokenId)=>{\n        try {\n            const contract = await connectingWithSmartContract();\n            const tx = await contract.burnNFT(tokenId);\n            await tx.wait();\n            router.push(\"/author\");\n            console.log(\"NFT burned successfully\");\n        } catch (error) {\n            console.error(\"Error burning NFT:\", error);\n        }\n    };\n    // cancel Sale NFT\n    const cancelSale = async (tokenId)=>{\n        try {\n            const contract = await connectingWithSmartContract();\n            const tx = await contract.cancelSale(tokenId);\n            await tx.wait();\n            router.push(\"/author\");\n            console.log(\"NFT sale canceled successfully\");\n        } catch (error) {\n            console.error(\"Error canceling NFT sale:\", error);\n        }\n    };\n    const getSigner = async ()=>{\n        try {\n            const web3Modal = new (web3modal__WEBPACK_IMPORTED_MODULE_2___default())();\n            const connection = await web3Modal.connect();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.BrowserProvider(connection);\n            const signer = await provider.getSigner();\n            return signer;\n        } catch (error) {\n            console.error(\"Error getting signer:\", error);\n            throw error;\n        }\n    };\n    const transferNFT = async (tokenId, address)=>{\n        try {\n            console.log(\"Tranfer to: \", tokenId, address);\n            const contract = await connectingWithSmartContract();\n            const signer = await getSigner();\n            const tx = await contract.connect(signer)[\"transferFrom(address,address,uint256)\"](currentAccount, address, tokenId);\n            const receipt = await tx.wait();\n            if (receipt.status === 1) {\n                console.log(\"NFT transferred successfully!\");\n            } else {\n                console.error(\"Transaction failed with error:\", receipt.status);\n            }\n        } catch (error) {\n            console.error(\"Error transferring NFT:\", error);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(NFTMarketplaceContext.Provider, {\n        value: {\n            uploadToPinata,\n            checkIfWalletConnected,\n            connectWallet,\n            createNFT,\n            fetchNFTs,\n            fetchMyNFTsOrListedNFTs,\n            buyNFT,\n            burnNFT,\n            cancelSale,\n            createSale,\n            transferNFT,\n            currentAccount,\n            titleData,\n            setOpenError,\n            openError,\n            error,\n            accountBalance\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\ninht\\\\OneDrive\\\\M\\xe1y t\\xednh\\\\Đồ \\xc1n\\\\Code\\\\connectingcontract\\\\Context\\\\NFTMarketplaceContext.js\",\n        lineNumber: 397,\n        columnNumber: 5\n    }, undefined);\n};\n_s(NFTMarketplaceProvider, \"CDZ9ygI5YG/J3HxjLK+h1omYzF0=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter\n    ];\n});\n_c = NFTMarketplaceProvider;\nvar _c;\n$RefreshReg$(_c, \"NFTMarketplaceProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FBVyxJQUFJakIsMENBQU1BLENBQUNrQixlQUFlLENBQUNIO1lBQzVDLE1BQU1JLFNBQVMsTUFBTUYsU0FBU0csU0FBUztZQUN2QyxPQUFPRDtRQUNULEVBQUUsT0FBT0csT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMseUJBQXlCQTtZQUN2QyxNQUFNQTtRQUNSO0lBQ0Y7SUFDQSxNQUFNdUYsY0FBYyxPQUFPekQsU0FBU0k7UUFDbEMsSUFBSTtZQUNGakMsUUFBUUMsR0FBRyxDQUFDLGdCQUFlNEIsU0FBU0k7WUFDcEMsTUFBTTdDLFdBQVcsTUFBTUQ7WUFDdkIsTUFBTVMsU0FBUyxNQUFNQztZQUVyQixNQUFNdUYsS0FBSyxNQUFNaEcsU0FBU0ssT0FBTyxDQUFDRyxPQUFPLENBQUMsd0NBQXdDLENBQUNjLGdCQUFnQnVCLFNBQVNKO1lBQzVHLE1BQU0wRCxVQUFVLE1BQU1ILEdBQUdsRCxJQUFJO1lBRTdCLElBQUlxRCxRQUFRQyxNQUFNLEtBQUssR0FBRztnQkFDeEJ4RixRQUFRQyxHQUFHLENBQUM7WUFDZCxPQUFPO2dCQUNMRCxRQUFRRCxLQUFLLENBQUMsa0NBQWtDd0YsUUFBUUMsTUFBTTtZQUNoRTtRQUNGLEVBQUUsT0FBT3pGLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDJCQUEyQkE7UUFDM0M7SUFDRjtJQUVFLHFCQUNFLDhEQUFDRyxzQkFBc0J1RixRQUFRO1FBQzdCeEIsT0FBTztZQUNMN0I7WUFDQXJCO1lBQ0FvQjtZQUNBYTtZQUNBbUI7WUFDQVc7WUFDQUc7WUFDQUU7WUFDQUU7WUFDQTlCO1lBQ0ErQjtZQUNBNUU7WUFDQUo7WUFDQUc7WUFDQUQ7WUFDQVQ7WUFDQWE7UUFDRjtrQkFFQ1A7Ozs7OztBQUdQLEVBQUU7R0FuWFdEOztRQVFJMUIsa0RBQVNBOzs7S0FSYjBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL0NvbnRleHQvTkZUTWFya2V0cGxhY2VDb250ZXh0LmpzP2MwNTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IFdlYjNNb2RhbCBmcm9tIFwid2ViM21vZGFsXCI7XHJcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvcm91dGVyXCI7XHJcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcclxuXHJcbi8vSU5URVJOQUwgIElNUE9SVFxyXG5pbXBvcnQge1xyXG4gIE5GVE1hcmtldHBsYWNlQWRkcmVzcyxcclxuICBORlRNYXJrZXRwbGFjZUFCSSxcclxuICB0cmFuc2ZlckZ1bmRzQWRkcmVzcyxcclxuICB0cmFuc2ZlckZ1bmRzQUJJLFxyXG59IGZyb20gXCIuL2NvbnN0YW50c1wiO1xyXG5cclxuLy8tLS1GRVRDSElORyBTTUFSVCBDT05UUkFDVFxyXG5jb25zdCBmZXRjaENvbnRyYWN0ID0gKHNpZ25lck9yUHJvdmlkZXIpID0+XHJcbiAgbmV3IGV0aGVycy5Db250cmFjdChcclxuICAgIE5GVE1hcmtldHBsYWNlQWRkcmVzcyxcclxuICAgIE5GVE1hcmtldHBsYWNlQUJJLFxyXG4gICAgc2lnbmVyT3JQcm92aWRlclxyXG4gICk7XHJcblxyXG4vLy0tLUNPTk5FQ1RJTkcgV0lUSCBTTUFSVCBDT05UUkFDVFxyXG5cclxuY29uc3QgY29ubmVjdGluZ1dpdGhTbWFydENvbnRyYWN0ID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBsZXQgY29udHJhY3Q7XHJcbiAgICBpZiAod2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgIGNvbnN0IHdlYjNNb2RhbCA9IG5ldyBXZWIzTW9kYWwoKTtcclxuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHdlYjNNb2RhbC5jb25uZWN0KCk7XHJcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIoY29ubmVjdGlvbik7XHJcbiAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgICBjb250cmFjdCA9IGZldGNoQ29udHJhY3Qoc2lnbmVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFPhu60gZOG7pW5nIG3hu5l0IG5vZGUgRXRoZXJldW0gY8O0bmcga2hhaSDhu58gxJHDonksIHbDrSBk4bulOiBJbmZ1cmEsIEFsY2hlbXksIC4uLlxyXG4gICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKCdodHRwczovL2V0aC1zZXBvbGlhLmcuYWxjaGVteS5jb20vdjIvQVJERHEwellUa1hTWWpGWklyWHBNei1qb3EwN3hLT28nKTtcclxuICAgICAgY29udHJhY3QgPSBmZXRjaENvbnRyYWN0KHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250cmFjdDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5sb2coXCJTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBjb25uZWN0aW5nIHdpdGggY29udHJhY3RcIiwgZXJyb3IpO1xyXG4gICAgLy8gTuG6v3UgY8OzIGzhu5dpLCBraOG7n2kgdOG6oW8gY29udHJhY3QgduG7m2kgcHJvdmlkZXIga2jDtG5nIMSRxINuZyBuaOG6rXBcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoJ2h0dHBzOi8vZXRoLXNlcG9saWEuZy5hbGNoZW15LmNvbS92Mi9BUkREcTB6WVRrWFNZakZaSXJYcE16LWpvcTA3eEtPbycpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBmZXRjaENvbnRyYWN0KHByb3ZpZGVyKTtcclxuICAgIHJldHVybiBjb250cmFjdDtcclxuICB9XHJcbn07XHJcbmV4cG9ydCBjb25zdCBORlRNYXJrZXRwbGFjZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KCk7XHJcblxyXG5leHBvcnQgY29uc3QgTkZUTWFya2V0cGxhY2VQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcclxuICBjb25zdCB0aXRsZURhdGEgPSBcIkRpc2NvdmVyLCBjb2xsZWN0LCBhbmQgc2VsbCBORlRzXCI7XHJcblxyXG4gIC8vLS0tLS0tVVNFU1RBVFxyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgY29uc3QgW29wZW5FcnJvciwgc2V0T3BlbkVycm9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbY3VycmVudEFjY291bnQsIHNldEN1cnJlbnRBY2NvdW50XSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gIGNvbnN0IFthY2NvdW50QmFsYW5jZSwgc2V0QWNjb3VudEJhbGFuY2VdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcblxyXG4gIC8vLS0tQ0hFQ0sgSUYgV0FMTEVUIElTIENPTk5FQ1REXHJcblxyXG4gIGNvbnN0IGNoZWNrSWZXYWxsZXRDb25uZWN0ZWQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSlcclxuICAgICAgICByZXR1cm4gc2V0T3BlbkVycm9yKHRydWUpLCBzZXRFcnJvcihcIkluc3RhbGwgTWV0YU1hc2tcIik7XHJcblxyXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0KHtcclxuICAgICAgICBtZXRob2Q6IFwiZXRoX2FjY291bnRzXCIsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCkge1xyXG4gICAgICAgIHNldEN1cnJlbnRBY2NvdW50KGFjY291bnRzWzBdKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhhY2NvdW50c1swXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gc2V0RXJyb3IoXCJObyBBY2NvdW50IEZvdW5kXCIpO1xyXG4gICAgICAgIC8vIHNldE9wZW5FcnJvcih0cnVlKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGFjY291bnRcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcclxuICAgICAgY29uc3QgZ2V0QmFsYW5jZSA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UoYWNjb3VudHNbMF0pO1xyXG4gICAgICBjb25zdCBiYWwgPSBldGhlcnMuZm9ybWF0RXRoZXIoZ2V0QmFsYW5jZSk7XHJcbiAgICAgIHNldEFjY291bnRCYWxhbmNlKGJhbCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBzZXRFcnJvcihcIlNvbWV0aGluZyB3cm9uZyB3aGlsZSBjb25uZWN0aW5nIHRvIHdhbGxldFwiKTtcclxuICAgICAgLy8gc2V0T3BlbkVycm9yKHRydWUpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIm5vdCBjb25uZWN0ZWRcIik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNoZWNrSWZXYWxsZXRDb25uZWN0ZWQoKTtcclxuICB9LCBbXSk7XHJcbiAgY29uc3QgYXBwcm92ZUFsbE5GVHMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGNvbm5lY3RpbmdXaXRoU21hcnRDb250cmFjdCgpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgY29udHJhY3QuZmV0Y2hNeU5GVHMoKTtcclxuICBcclxuICAgICAgLy8gTOG6pXkgZGFuaCBzw6FjaCB0b2tlbklkXHJcbiAgICAgIGNvbnN0IHRva2VuSWRzID0gZGF0YS5tYXAoKG5mdCkgPT4gbmZ0LnRva2VuSWQudG9TdHJpbmcoKSk7XHJcbiAgXHJcbiAgICAgIC8vIEFwcHJvdmUgdOG7q25nIE5GVFxyXG4gICAgICBmb3IgKGNvbnN0IHRva2VuSWQgb2YgdG9rZW5JZHMpIHtcclxuICAgICAgICBjb25zdCBhcHByb3ZhbFR4ID0gYXdhaXQgY29udHJhY3QuYXBwcm92ZShjb250cmFjdC5hZGRyZXNzLCB0b2tlbklkKTtcclxuICAgICAgICBhd2FpdCBhcHByb3ZhbFR4LndhaXQoKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnQXBwcm92ZWQgTkZUIHdpdGggdG9rZW4gSUQgJHt0b2tlbklkfScpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHByb3ZpbmcgTkZUczonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLy0tLUNPTk5FVCBXQUxMRVQgRlVOQ1RJT05cclxuICBjb25zdCBjb25uZWN0V2FsbGV0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pXHJcbiAgICAgICAgcmV0dXJuIHNldE9wZW5FcnJvcih0cnVlKSwgc2V0RXJyb3IoXCJJbnN0YWxsIE1ldGFNYXNrXCIpO1xyXG5cclxuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7XHJcbiAgICAgICAgbWV0aG9kOiBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIixcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhhY2NvdW50cyk7XHJcbiAgICAgIHNldEN1cnJlbnRBY2NvdW50KGFjY291bnRzWzBdKTtcclxuXHJcbiAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgY29ubmVjdGluZ1dpdGhTbWFydENvbnRyYWN0KCk7XHJcbiAgICAgIGF3YWl0IGFwcHJvdmVBbGxORlRzKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBzZXRFcnJvcihcIkVycm9yIHdoaWxlIGNvbm5lY3RpbmcgdG8gd2FsbGV0XCIpO1xyXG4gICAgICAvLyBzZXRPcGVuRXJyb3IodHJ1ZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8tLS1VUExPQUQgVE8gSVBGUyBGVU5DVElPTlxyXG4gIGNvbnN0IHVwbG9hZFRvUGluYXRhID0gYXN5bmMgKGZpbGUpID0+IHtcclxuICAgIGlmIChmaWxlKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGZpbGUpO1xyXG5cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zKHtcclxuICAgICAgICAgIG1ldGhvZDogXCJwb3N0XCIsXHJcbiAgICAgICAgICB1cmw6IFwiaHR0cHM6Ly9hcGkucGluYXRhLmNsb3VkL3Bpbm5pbmcvcGluRmlsZVRvSVBGU1wiLFxyXG4gICAgICAgICAgZGF0YTogZm9ybURhdGEsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgIHBpbmF0YV9hcGlfa2V5OiBgZDJjNzdhMDhmOGRlNzY2NjMyZDBgLFxyXG4gICAgICAgICAgICBwaW5hdGFfc2VjcmV0X2FwaV9rZXk6IGBcclxuICAgICAgICAgICAgOTU0NmNiNjlhODYzNDIyOWQ5NWU3NTBlNTI2ZmVkZDE0ZWViN2M4ODU2YzEyZTBhZTljNGIxYmQwZTU2NzQ0ZWAsXHJcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBJbWdIYXNoID0gYGh0dHBzOi8vZ2F0ZXdheS5waW5hdGEuY2xvdWQvaXBmcy8ke3Jlc3BvbnNlLmRhdGEuSXBmc0hhc2h9YDtcclxuXHJcbiAgICAgICAgcmV0dXJuIEltZ0hhc2g7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJVbmFibGUgdG8gdXBsb2FkIGltYWdlIHRvIFBpbmF0YVwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vLS0tQ1JFQVRFTkZUIEZVTkNUSU9OXHJcbiAgY29uc3QgY3JlYXRlTkZUID0gYXN5bmMgKG5hbWUsIHByaWNlLCBpbWFnZSwgZGVzY3JpcHRpb24sIHJvdXRlcikgPT4ge1xyXG4gICAgaWYgKCFuYW1lIHx8ICFkZXNjcmlwdGlvbiB8fCAhcHJpY2UgfHwgIWltYWdlKVxyXG4gICAgICByZXR1cm4gc2V0RXJyb3IoXCJEYXRhIElzIE1pc3NpbmdcIiksIHNldE9wZW5FcnJvcih0cnVlKTtcclxuXHJcbiAgICBjb25zdCBkYXRhID0gSlNPTi5zdHJpbmdpZnkoeyBuYW1lLCBkZXNjcmlwdGlvbiwgaW1hZ2UgfSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcyh7XHJcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9hcGkucGluYXRhLmNsb3VkL3Bpbm5pbmcvcGluSlNPTlRvSVBGU1wiLFxyXG4gICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgcGluYXRhX2FwaV9rZXk6IGBkMmM3N2EwOGY4ZGU3NjY2MzJkMGAsXHJcbiAgICAgICAgICBwaW5hdGFfc2VjcmV0X2FwaV9rZXk6IGBcclxuICAgICAgICAgIDk1NDZjYjY5YTg2MzQyMjlkOTVlNzUwZTUyNmZlZGQxNGVlYjdjODg1NmMxMmUwYWU5YzRiMWJkMGU1Njc0NGVgLFxyXG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9nYXRld2F5LnBpbmF0YS5jbG91ZC9pcGZzLyR7cmVzcG9uc2UuZGF0YS5JcGZzSGFzaH1gO1xyXG4gICAgICBjb25zb2xlLmxvZyh1cmwpO1xyXG5cclxuICAgICAgYXdhaXQgY3JlYXRlU2FsZSh1cmwsIHByaWNlKTtcclxuICAgICAgcm91dGVyLnB1c2goXCIvc2VhcmNoUGFnZVwiKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHNldEVycm9yKFwiRXJyb3Igd2hpbGUgY3JlYXRpbmcgTkZUXCIpO1xyXG4gICAgICBzZXRPcGVuRXJyb3IodHJ1ZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8tLS0gY3JlYXRlU2FsZSBGVU5DVElPTlxyXG4gIGNvbnN0IGNyZWF0ZVNhbGUgPSBhc3luYyAodXJsLCBmb3JtSW5wdXRQcmljZSwgaXNSZXNlbGxpbmcsIGlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyh1cmwsIGZvcm1JbnB1dFByaWNlLCBpc1Jlc2VsbGluZywgaWQpO1xyXG4gICAgICBjb25zdCBwcmljZSA9IGV0aGVycy5wYXJzZVVuaXRzKGZvcm1JbnB1dFByaWNlLCBcImV0aGVyXCIpO1xyXG5cclxuICAgICAgY29uc3QgY29udHJhY3QgPSBhd2FpdCBjb25uZWN0aW5nV2l0aFNtYXJ0Q29udHJhY3QoKTtcclxuXHJcbiAgICAgIGNvbnN0IGxpc3RpbmdQcmljZSA9IGF3YWl0IGNvbnRyYWN0LmdldExpc3RpbmdQcmljZSgpO1xyXG5cclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAhaXNSZXNlbGxpbmdcclxuICAgICAgICA/IGF3YWl0IGNvbnRyYWN0LmNyZWF0ZVRva2VuKHVybCwgcHJpY2UsIHtcclxuICAgICAgICAgICAgdmFsdWU6IGxpc3RpbmdQcmljZS50b1N0cmluZygpLFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICA6IGF3YWl0IGNvbnRyYWN0LnJlc2VsbFRva2VuKGlkLCBwcmljZSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogbGlzdGluZ1ByaWNlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLndhaXQoKTtcclxuICAgICAgY29uc29sZS5sb2codHJhbnNhY3Rpb24pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgc2V0RXJyb3IoXCJlcnJvciB3aGlsZSBjcmVhdGluZyBzYWxlXCIpO1xyXG4gICAgICBzZXRPcGVuRXJyb3IodHJ1ZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLy0tRkVUQ0hORlRTIEZVTkNUSU9OXHJcblxyXG4gIGNvbnN0IGZldGNoTkZUcyA9IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgY29ubmVjdGluZ1dpdGhTbWFydENvbnRyYWN0KCk7XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgY29udHJhY3QuZmV0Y2hNYXJrZXRJdGVtcygpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coZGF0YSk7XHJcblxyXG4gICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICAgIGRhdGEubWFwKFxyXG4gICAgICAgICAgYXN5bmMgKHsgdG9rZW5JZCwgc2VsbGVyLCBvd25lciwgcHJpY2U6IHVuZm9ybWF0dGVkUHJpY2UgfSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodG9rZW5JZCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIC8vIELhu48gcXVhIHRva2VuSWQga2jDtG5nIGjhu6NwIGzhu4dcclxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0b2tlblVSSSA9IGF3YWl0IGNvbnRyYWN0LnRva2VuVVJJKHRva2VuSWQpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgIGRhdGE6IHsgaW1hZ2UsIG5hbWUsIGRlc2NyaXB0aW9uIH0sXHJcbiAgICAgICAgICAgIH0gPSBhd2FpdCBheGlvcy5nZXQodG9rZW5VUkksIHt9KTtcclxuICAgICAgICAgICAgY29uc3QgcHJpY2UgPSBldGhlcnMuZm9ybWF0VW5pdHMoXHJcbiAgICAgICAgICAgICAgdW5mb3JtYXR0ZWRQcmljZS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgIFwiZXRoZXJcIlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBwcmljZSxcclxuICAgICAgICAgICAgICB0b2tlbklkOiB0b2tlbklkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgc2VsbGVyLFxyXG4gICAgICAgICAgICAgIG93bmVyLFxyXG4gICAgICAgICAgICAgIGltYWdlLFxyXG4gICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgdG9rZW5VUkksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gaXRlbXM7XHJcblxyXG4gICAgICAvLyB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBzZXRFcnJvcihcIkVycm9yIHdoaWxlIGZldGNoaW5nIE5GVFNcIik7XHJcbiAgICAgIC8vIHNldE9wZW5FcnJvcih0cnVlKTtcclxuICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBmZXRjaE5GVHMoKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vLS1GRVRDSElORyBNWSBORlQgT1IgTElTVEVEIE5GVHNcclxuICBjb25zdCBmZXRjaE15TkZUc09yTGlzdGVkTkZUcyA9IGFzeW5jICh0eXBlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoY3VycmVudEFjY291bnQpIHtcclxuICAgICAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGNvbm5lY3RpbmdXaXRoU21hcnRDb250cmFjdCgpO1xyXG5cclxuICAgICAgICBjb25zdCBkYXRhID1cclxuICAgICAgICAgIHR5cGUgPT0gXCJmZXRjaEl0ZW1zTGlzdGVkXCJcclxuICAgICAgICAgICAgPyBhd2FpdCBjb250cmFjdC5mZXRjaEl0ZW1zTGlzdGVkKClcclxuICAgICAgICAgICAgOiBhd2FpdCBjb250cmFjdC5mZXRjaE15TkZUcygpO1xyXG5cclxuICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICAgICAgZGF0YS5tYXAoXHJcbiAgICAgICAgICAgIGFzeW5jICh7IHRva2VuSWQsIHNlbGxlciwgb3duZXIsIHByaWNlOiB1bmZvcm1hdHRlZFByaWNlIH0pID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB0b2tlblVSSSA9IGF3YWl0IGNvbnRyYWN0LnRva2VuVVJJKHRva2VuSWQpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHsgaW1hZ2UsIG5hbWUsIGRlc2NyaXB0aW9uIH0sXHJcbiAgICAgICAgICAgICAgfSA9IGF3YWl0IGF4aW9zLmdldCh0b2tlblVSSSk7XHJcbiAgICAgICAgICAgICAgY29uc3QgcHJpY2UgPSBldGhlcnMuZm9ybWF0VW5pdHMoXHJcbiAgICAgICAgICAgICAgICB1bmZvcm1hdHRlZFByaWNlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICBcImV0aGVyXCJcclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcHJpY2UsXHJcbiAgICAgICAgICAgICAgICB0b2tlbklkOiB0b2tlbklkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICBzZWxsZXIsXHJcbiAgICAgICAgICAgICAgICBvd25lcixcclxuICAgICAgICAgICAgICAgIGltYWdlLFxyXG4gICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAgdG9rZW5VUkksXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgIC8vIHNldEVycm9yKFwiRXJyb3Igd2hpbGUgZmV0Y2hpbmcgbGlzdGVkIE5GVHNcIik7XHJcbiAgICAgIC8vIHNldE9wZW5FcnJvcih0cnVlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZmV0Y2hNeU5GVHNPckxpc3RlZE5GVHMoKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vLS0tYnV5IE5GVFxyXG4gIGNvbnN0IGJ1eU5GVCA9IGFzeW5jIChuZnQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgY29ubmVjdGluZ1dpdGhTbWFydENvbnRyYWN0KCk7XHJcbiAgICAgIGNvbnN0IHByaWNlID0gZXRoZXJzLnBhcnNlVW5pdHMobmZ0LnByaWNlLnRvU3RyaW5nKCksIFwiZXRoZXJcIik7XHJcblxyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IGNvbnRyYWN0LmNyZWF0ZU1hcmtldFNhbGUobmZ0LnRva2VuSWQsIHtcclxuICAgICAgICB2YWx1ZTogcHJpY2UsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgYXdhaXQgdHJhbnNhY3Rpb24ud2FpdCgpO1xyXG4gICAgICByb3V0ZXIucHVzaChcIi9hdXRob3JcIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBzZXRFcnJvcihcIkVycm9yIFdoaWxlIGJ1eWluZyBORlRcIik7XHJcbiAgICAgIHNldE9wZW5FcnJvcih0cnVlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBEZWxldGUgTkZUXHJcbmNvbnN0IGJ1cm5ORlQgPSBhc3luYyAodG9rZW5JZCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGNvbm5lY3RpbmdXaXRoU21hcnRDb250cmFjdCgpO1xyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5idXJuTkZUKHRva2VuSWQpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgcm91dGVyLnB1c2goXCIvYXV0aG9yXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCJORlQgYnVybmVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGJ1cm5pbmcgTkZUOlwiLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gY2FuY2VsIFNhbGUgTkZUXHJcbmNvbnN0IGNhbmNlbFNhbGUgPSBhc3luYyAodG9rZW5JZCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGNvbm5lY3RpbmdXaXRoU21hcnRDb250cmFjdCgpO1xyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5jYW5jZWxTYWxlKHRva2VuSWQpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgcm91dGVyLnB1c2goXCIvYXV0aG9yXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCJORlQgc2FsZSBjYW5jZWxlZCBzdWNjZXNzZnVsbHlcIik7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYW5jZWxpbmcgTkZUIHNhbGU6XCIsIGVycm9yKTtcclxuICB9XHJcbn07XHJcbmNvbnN0IGdldFNpZ25lciA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgd2ViM01vZGFsID0gbmV3IFdlYjNNb2RhbCgpO1xyXG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHdlYjNNb2RhbC5jb25uZWN0KCk7XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKGNvbm5lY3Rpb24pO1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICByZXR1cm4gc2lnbmVyO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBzaWduZXI6XCIsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuY29uc3QgdHJhbnNmZXJORlQgPSBhc3luYyAodG9rZW5JZCwgYWRkcmVzcykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlRyYW5mZXIgdG86IFwiLHRva2VuSWQsIGFkZHJlc3MpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBhd2FpdCBjb25uZWN0aW5nV2l0aFNtYXJ0Q29udHJhY3QoKTtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGdldFNpZ25lcigpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuY29ubmVjdChzaWduZXIpW1widHJhbnNmZXJGcm9tKGFkZHJlc3MsYWRkcmVzcyx1aW50MjU2KVwiXShjdXJyZW50QWNjb3VudCwgYWRkcmVzcywgdG9rZW5JZCk7XHJcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIGlmIChyZWNlaXB0LnN0YXR1cyA9PT0gMSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIk5GVCB0cmFuc2ZlcnJlZCBzdWNjZXNzZnVsbHkhXCIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlRyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIGVycm9yOlwiLCByZWNlaXB0LnN0YXR1cyk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB0cmFuc2ZlcnJpbmcgTkZUOlwiLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPE5GVE1hcmtldHBsYWNlQ29udGV4dC5Qcm92aWRlclxyXG4gICAgICB2YWx1ZT17e1xyXG4gICAgICAgIHVwbG9hZFRvUGluYXRhLFxyXG4gICAgICAgIGNoZWNrSWZXYWxsZXRDb25uZWN0ZWQsXHJcbiAgICAgICAgY29ubmVjdFdhbGxldCxcclxuICAgICAgICBjcmVhdGVORlQsXHJcbiAgICAgICAgZmV0Y2hORlRzLFxyXG4gICAgICAgIGZldGNoTXlORlRzT3JMaXN0ZWRORlRzLFxyXG4gICAgICAgIGJ1eU5GVCxcclxuICAgICAgICBidXJuTkZULFxyXG4gICAgICAgIGNhbmNlbFNhbGUsXHJcbiAgICAgICAgY3JlYXRlU2FsZSxcclxuICAgICAgICB0cmFuc2Zlck5GVCxcclxuICAgICAgICBjdXJyZW50QWNjb3VudCxcclxuICAgICAgICB0aXRsZURhdGEsXHJcbiAgICAgICAgc2V0T3BlbkVycm9yLFxyXG4gICAgICAgIG9wZW5FcnJvcixcclxuICAgICAgICBlcnJvcixcclxuICAgICAgICBhY2NvdW50QmFsYW5jZSxcclxuICAgICAgfX1cclxuICAgID5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9ORlRNYXJrZXRwbGFjZUNvbnRleHQuUHJvdmlkZXI+XHJcbiAgKTtcclxufTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIldlYjNNb2RhbCIsImV0aGVycyIsInVzZVJvdXRlciIsImF4aW9zIiwiTkZUTWFya2V0cGxhY2VBZGRyZXNzIiwiTkZUTWFya2V0cGxhY2VBQkkiLCJ0cmFuc2ZlckZ1bmRzQWRkcmVzcyIsInRyYW5zZmVyRnVuZHNBQkkiLCJmZXRjaENvbnRyYWN0Iiwic2lnbmVyT3JQcm92aWRlciIsIkNvbnRyYWN0IiwiY29ubmVjdGluZ1dpdGhTbWFydENvbnRyYWN0IiwiY29udHJhY3QiLCJ3aW5kb3ciLCJldGhlcmV1bSIsIndlYjNNb2RhbCIsImNvbm5lY3Rpb24iLCJjb25uZWN0IiwicHJvdmlkZXIiLCJCcm93c2VyUHJvdmlkZXIiLCJzaWduZXIiLCJnZXRTaWduZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJORlRNYXJrZXRwbGFjZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiTkZUTWFya2V0cGxhY2VQcm92aWRlciIsImNoaWxkcmVuIiwidGl0bGVEYXRhIiwic2V0RXJyb3IiLCJvcGVuRXJyb3IiLCJzZXRPcGVuRXJyb3IiLCJjdXJyZW50QWNjb3VudCIsInNldEN1cnJlbnRBY2NvdW50IiwiYWNjb3VudEJhbGFuY2UiLCJzZXRBY2NvdW50QmFsYW5jZSIsInJvdXRlciIsImNoZWNrSWZXYWxsZXRDb25uZWN0ZWQiLCJhY2NvdW50cyIsInJlcXVlc3QiLCJtZXRob2QiLCJsZW5ndGgiLCJnZXRCYWxhbmNlIiwiYmFsIiwiZm9ybWF0RXRoZXIiLCJhcHByb3ZlQWxsTkZUcyIsImRhdGEiLCJmZXRjaE15TkZUcyIsInRva2VuSWRzIiwibWFwIiwibmZ0IiwidG9rZW5JZCIsInRvU3RyaW5nIiwiYXBwcm92YWxUeCIsImFwcHJvdmUiLCJhZGRyZXNzIiwid2FpdCIsImNvbm5lY3RXYWxsZXQiLCJ1cGxvYWRUb1BpbmF0YSIsImZpbGUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwicmVzcG9uc2UiLCJ1cmwiLCJoZWFkZXJzIiwicGluYXRhX2FwaV9rZXkiLCJwaW5hdGFfc2VjcmV0X2FwaV9rZXkiLCJJbWdIYXNoIiwiSXBmc0hhc2giLCJjcmVhdGVORlQiLCJuYW1lIiwicHJpY2UiLCJpbWFnZSIsImRlc2NyaXB0aW9uIiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZVNhbGUiLCJwdXNoIiwiZm9ybUlucHV0UHJpY2UiLCJpc1Jlc2VsbGluZyIsImlkIiwicGFyc2VVbml0cyIsImxpc3RpbmdQcmljZSIsImdldExpc3RpbmdQcmljZSIsInRyYW5zYWN0aW9uIiwiY3JlYXRlVG9rZW4iLCJ2YWx1ZSIsInJlc2VsbFRva2VuIiwiZmV0Y2hORlRzIiwiZmV0Y2hNYXJrZXRJdGVtcyIsIml0ZW1zIiwiUHJvbWlzZSIsImFsbCIsInNlbGxlciIsIm93bmVyIiwidW5mb3JtYXR0ZWRQcmljZSIsInRva2VuVVJJIiwiZ2V0IiwiZm9ybWF0VW5pdHMiLCJmZXRjaE15TkZUc09yTGlzdGVkTkZUcyIsInR5cGUiLCJmZXRjaEl0ZW1zTGlzdGVkIiwiYnV5TkZUIiwiY3JlYXRlTWFya2V0U2FsZSIsImJ1cm5ORlQiLCJ0eCIsImNhbmNlbFNhbGUiLCJ0cmFuc2Zlck5GVCIsInJlY2VpcHQiLCJzdGF0dXMiLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./Context/NFTMarketplaceContext.js\n"));

/***/ })

});
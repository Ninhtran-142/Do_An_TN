"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./Context/NFTMarketplaceContext.js":
/*!******************************************!*\
  !*** ./Context/NFTMarketplaceContext.js ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NFTMarketplaceContext: function() { return /* binding */ NFTMarketplaceContext; },\n/* harmony export */   NFTMarketplaceProvider: function() { return /* binding */ NFTMarketplaceProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var web3modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! web3modal */ \"./node_modules/web3modal/dist/index.js\");\n/* harmony import */ var web3modal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(web3modal__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ \"./Context/constants.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n//INTERNAL  IMPORT\n\n//---FETCHING SMART CONTRACT\nconst fetchContract = (signerOrProvider)=>new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(_constants__WEBPACK_IMPORTED_MODULE_4__.NFTMarketplaceAddress, _constants__WEBPACK_IMPORTED_MODULE_4__.NFTMarketplaceABI, signerOrProvider);\n//---CONNECTING WITH SMART CONTRACT\nconst connectingWithSmartContract = async ()=>{\n    try {\n        let contract;\n        if (window.ethereum) {\n            const web3Modal = new (web3modal__WEBPACK_IMPORTED_MODULE_2___default())();\n            const connection = await web3Modal.connect();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.BrowserProvider(connection);\n            const signer = await provider.getSigner();\n            contract = fetchContract(signer);\n        } else {\n            // Sử dụng một node Ethereum công khai ở đây, ví dụ: Infura, Alchemy, ...\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(\"https://eth-sepolia.g.alchemy.com/v2/ARDDq0zYTkXSYjFZIrXpMz-joq07xKOo\");\n            contract = fetchContract(provider);\n        }\n        return contract;\n    } catch (error) {\n        console.log(\"Something went wrong while connecting with contract\", error);\n        // Nếu có lỗi, khởi tạo contract với provider không đăng nhập\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(\"https://eth-sepolia.g.alchemy.com/v2/ARDDq0zYTkXSYjFZIrXpMz-joq07xKOo\");\n        const contract = fetchContract(provider);\n        return contract;\n    }\n};\nconst NFTMarketplaceContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext();\nconst NFTMarketplaceProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const titleData = \"Discover, collect, and sell NFTs\";\n    //------USESTAT\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [openError, setOpenError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentAccount, setCurrentAccount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [accountBalance, setAccountBalance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    //---CHECK IF WALLET IS CONNECTD\n    const checkIfWalletConnected = async ()=>{\n        try {\n            if (!window.ethereum) return setOpenError(true), setError(\"Install MetaMask\");\n            const accounts = await window.ethereum.request({\n                method: \"eth_accounts\"\n            });\n            if (accounts.length) {\n                setCurrentAccount(accounts[0]);\n                console.log(accounts[0]);\n            } else {\n                // setError(\"No Account Found\");\n                // setOpenError(true);\n                console.log(\"No account\");\n            }\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.BrowserProvider(window.ethereum);\n            const getBalance = await provider.getBalance(accounts[0]);\n            const bal = ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.formatEther(getBalance);\n            setAccountBalance(bal);\n        } catch (error) {\n            // setError(\"Something wrong while connecting to wallet\");\n            // setOpenError(true);\n            console.log(\"not connected\");\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        checkIfWalletConnected();\n    }, []);\n    const approveAllNFTs = async ()=>{\n        try {\n            const contract = await connectingWithSmartContract();\n            const data = await contract.fetchMyNFTs();\n            // Lấy danh sách tokenId\n            const tokenIds = data.map((nft)=>nft.tokenId.toString());\n            // Approve từng NFT\n            for (const tokenId of tokenIds){\n                const approvalTx = await contract.approve(contract.address, tokenId);\n                await approvalTx.wait();\n                console.log(\"Approved NFT with token ID ${tokenId}\");\n            }\n        } catch (error) {\n            console.error(\"Error approving NFTs:\", error);\n        }\n    };\n    //---CONNET WALLET FUNCTION\n    const connectWallet = async ()=>{\n        try {\n            if (!window.ethereum) return setOpenError(true), setError(\"Install MetaMask\");\n            const accounts = await window.ethereum.request({\n                method: \"eth_requestAccounts\"\n            });\n            console.log(accounts);\n            setCurrentAccount(accounts[0]);\n            // window.location.reload();\n            connectingWithSmartContract();\n            await approveAllNFTs();\n        } catch (error) {\n        // setError(\"Error while connecting to wallet\");\n        // setOpenError(true);\n        }\n    };\n    //---UPLOAD TO IPFS FUNCTION\n    const uploadToPinata = async (file)=>{\n        if (file) {\n            try {\n                const formData = new FormData();\n                formData.append(\"file\", file);\n                const response = await (0,axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n                    method: \"post\",\n                    url: \"https://api.pinata.cloud/pinning/pinFileToIPFS\",\n                    data: formData,\n                    headers: {\n                        pinata_api_key: \"d2c77a08f8de766632d0\",\n                        pinata_secret_api_key: \"\\n            9546cb69a8634229d95e750e526fedd14eeb7c8856c12e0ae9c4b1bd0e56744e\",\n                        \"Content-Type\": \"multipart/form-data\"\n                    }\n                });\n                const ImgHash = \"https://gateway.pinata.cloud/ipfs/\".concat(response.data.IpfsHash);\n                return ImgHash;\n            } catch (error) {\n                console.log(\"Unable to upload image to Pinata\");\n            }\n        }\n    };\n    //---CREATENFT FUNCTION\n    const createNFT = async (name, price, image, description, router)=>{\n        if (!name || !description || !price || !image) return setError(\"Data Is Missing\"), setOpenError(true);\n        const data = JSON.stringify({\n            name,\n            description,\n            image\n        });\n        try {\n            const response = await (0,axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n                method: \"POST\",\n                url: \"https://api.pinata.cloud/pinning/pinJSONToIPFS\",\n                data: data,\n                headers: {\n                    pinata_api_key: \"d2c77a08f8de766632d0\",\n                    pinata_secret_api_key: \"\\n          9546cb69a8634229d95e750e526fedd14eeb7c8856c12e0ae9c4b1bd0e56744e\",\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            const url = \"https://gateway.pinata.cloud/ipfs/\".concat(response.data.IpfsHash);\n            console.log(url);\n            await createSale(url, price);\n            router.push(\"/searchPage\");\n        } catch (error) {\n            setError(\"Error while creating NFT\");\n            setOpenError(true);\n        }\n    };\n    //--- createSale FUNCTION\n    const createSale = async (url, formInputPrice, isReselling, id)=>{\n        try {\n            console.log(url, formInputPrice, isReselling, id);\n            const price = ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.parseUnits(formInputPrice, \"ether\");\n            const contract = await connectingWithSmartContract();\n            const listingPrice = await contract.getListingPrice();\n            const transaction = !isReselling ? await contract.createToken(url, price, {\n                value: listingPrice.toString()\n            }) : await contract.resellToken(id, price, {\n                value: listingPrice.toString()\n            });\n            await transaction.wait();\n            console.log(transaction);\n        } catch (error) {\n            setError(\"error while creating sale\");\n            setOpenError(true);\n            console.log(error);\n        }\n    };\n    //--FETCHNFTS FUNCTION\n    const fetchNFTs = async ()=>{\n        try {\n            const web3Modal = new (web3modal__WEBPACK_IMPORTED_MODULE_2___default())();\n            const connection = await web3Modal.connect();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.BrowserProvider(connection);\n            const contract = fetchContract(provider);\n            const data = await contract.fetchMarketItems();\n            console.log(data);\n            const items = await Promise.all(data.map(async (param)=>{\n                let { tokenId, seller, owner, price: unformattedPrice } = param;\n                if (tokenId === 0) {\n                    // Bỏ qua tokenId không hợp lệ\n                    return null;\n                }\n                const tokenURI = await contract.tokenURI(tokenId);\n                const { data: { image, name, description } } = await axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(tokenURI, {});\n                const price = ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.formatUnits(unformattedPrice.toString(), \"ether\");\n                return {\n                    price,\n                    tokenId: tokenId.toString(),\n                    seller,\n                    owner,\n                    image,\n                    name,\n                    description,\n                    tokenURI\n                };\n            }));\n            return items;\n        // }\n        } catch (error) {\n            // setError(\"Error while fetching NFTS\");\n            // setOpenError(true);\n            console.log(error);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        fetchNFTs();\n    }, []);\n    //--FETCHING MY NFT OR LISTED NFTs\n    const fetchMyNFTsOrListedNFTs = async (type)=>{\n        try {\n            if (currentAccount) {\n                const contract = await connectingWithSmartContract();\n                const data = type == \"fetchItemsListed\" ? await contract.fetchItemsListed() : await contract.fetchMyNFTs();\n                const items = await Promise.all(data.map(async (param)=>{\n                    let { tokenId, seller, owner, price: unformattedPrice } = param;\n                    const tokenURI = await contract.tokenURI(tokenId);\n                    const { data: { image, name, description } } = await axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(tokenURI);\n                    const price = ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.formatUnits(unformattedPrice.toString(), \"ether\");\n                    return {\n                        price,\n                        tokenId: tokenId.toString(),\n                        seller,\n                        owner,\n                        image,\n                        name,\n                        description,\n                        tokenURI\n                    };\n                }));\n                return items;\n            }\n        } catch (error) {\n            console.log(error);\n        // setError(\"Error while fetching listed NFTs\");\n        // setOpenError(true);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        fetchMyNFTsOrListedNFTs();\n    }, []);\n    //---buy NFT\n    const buyNFT = async (nft)=>{\n        try {\n            const contract = await connectingWithSmartContract();\n            const price = ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.parseUnits(nft.price.toString(), \"ether\");\n            const transaction = await contract.createMarketSale(nft.tokenId, {\n                value: price\n            });\n            await transaction.wait();\n            router.push(\"/author\");\n        } catch (error) {\n            setError(\"Error While buying NFT\");\n            setOpenError(true);\n        }\n    };\n    // Delete NFT\n    const burnNFT = async (tokenId)=>{\n        try {\n            const contract = await connectingWithSmartContract();\n            const tx = await contract.burnNFT(tokenId);\n            await tx.wait();\n            router.push(\"/author\");\n            console.log(\"NFT burned successfully\");\n        } catch (error) {\n            console.error(\"Error burning NFT:\", error);\n        }\n    };\n    // cancel Sale NFT\n    const cancelSale = async (tokenId)=>{\n        try {\n            const contract = await connectingWithSmartContract();\n            const tx = await contract.cancelSale(tokenId);\n            await tx.wait();\n            router.push(\"/author\");\n            console.log(\"NFT sale canceled successfully\");\n        } catch (error) {\n            console.error(\"Error canceling NFT sale:\", error);\n        }\n    };\n    const getSigner = async ()=>{\n        try {\n            const web3Modal = new (web3modal__WEBPACK_IMPORTED_MODULE_2___default())();\n            const connection = await web3Modal.connect();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.BrowserProvider(connection);\n            const signer = await provider.getSigner();\n            return signer;\n        } catch (error) {\n            console.error(\"Error getting signer:\", error);\n            throw error;\n        }\n    };\n    const transferNFT = async (tokenId, address)=>{\n        try {\n            console.log(\"Tranfer to: \", tokenId, address);\n            const contract = await connectingWithSmartContract();\n            const signer = await getSigner();\n            const tx = await contract.connect(signer)[\"transferFrom(address,address,uint256)\"](currentAccount, address, tokenId);\n            const receipt = await tx.wait();\n            if (receipt.status === 1) {\n                console.log(\"NFT transferred successfully!\");\n            } else {\n                console.error(\"Transaction failed with error:\", receipt.status);\n            }\n        } catch (error) {\n            console.error(\"Error transferring NFT:\", error);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(NFTMarketplaceContext.Provider, {\n        value: {\n            uploadToPinata,\n            checkIfWalletConnected,\n            connectWallet,\n            createNFT,\n            fetchNFTs,\n            fetchMyNFTsOrListedNFTs,\n            buyNFT,\n            burnNFT,\n            cancelSale,\n            createSale,\n            transferNFT,\n            currentAccount,\n            titleData,\n            setOpenError,\n            openError,\n            error,\n            accountBalance\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\ninht\\\\OneDrive\\\\M\\xe1y t\\xednh\\\\Đồ \\xc1n\\\\Code\\\\connectingcontract\\\\Context\\\\NFTMarketplaceContext.js\",\n        lineNumber: 401,\n        columnNumber: 5\n    }, undefined);\n};\n_s(NFTMarketplaceProvider, \"CDZ9ygI5YG/J3HxjLK+h1omYzF0=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter\n    ];\n});\n_c = NFTMarketplaceProvider;\nvar _c;\n$RefreshReg$(_c, \"NFTMarketplaceProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UmIwQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9Db250ZXh0L05GVE1hcmtldHBsYWNlQ29udGV4dC5qcz9jMDUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBXZWIzTW9kYWwgZnJvbSBcIndlYjNtb2RhbFwiO1xyXG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tIFwiZXRoZXJzXCI7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xyXG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XHJcblxyXG4vL0lOVEVSTkFMICBJTVBPUlRcclxuaW1wb3J0IHtcclxuICBORlRNYXJrZXRwbGFjZUFkZHJlc3MsXHJcbiAgTkZUTWFya2V0cGxhY2VBQkksXHJcbiAgdHJhbnNmZXJGdW5kc0FkZHJlc3MsXHJcbiAgdHJhbnNmZXJGdW5kc0FCSSxcclxufSBmcm9tIFwiLi9jb25zdGFudHNcIjtcclxuXHJcbi8vLS0tRkVUQ0hJTkcgU01BUlQgQ09OVFJBQ1RcclxuY29uc3QgZmV0Y2hDb250cmFjdCA9IChzaWduZXJPclByb3ZpZGVyKSA9PlxyXG4gIG5ldyBldGhlcnMuQ29udHJhY3QoXHJcbiAgICBORlRNYXJrZXRwbGFjZUFkZHJlc3MsXHJcbiAgICBORlRNYXJrZXRwbGFjZUFCSSxcclxuICAgIHNpZ25lck9yUHJvdmlkZXJcclxuICApO1xyXG5cclxuLy8tLS1DT05ORUNUSU5HIFdJVEggU01BUlQgQ09OVFJBQ1RcclxuXHJcbmNvbnN0IGNvbm5lY3RpbmdXaXRoU21hcnRDb250cmFjdCA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgbGV0IGNvbnRyYWN0O1xyXG4gICAgaWYgKHdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICBjb25zdCB3ZWIzTW9kYWwgPSBuZXcgV2ViM01vZGFsKCk7XHJcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB3ZWIzTW9kYWwuY29ubmVjdCgpO1xyXG4gICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKGNvbm5lY3Rpb24pO1xyXG4gICAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgICAgY29udHJhY3QgPSBmZXRjaENvbnRyYWN0KHNpZ25lcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBT4butIGThu6VuZyBt4buZdCBub2RlIEV0aGVyZXVtIGPDtG5nIGtoYWkg4bufIMSRw6J5LCB2w60gZOG7pTogSW5mdXJhLCBBbGNoZW15LCAuLi5cclxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcignaHR0cHM6Ly9ldGgtc2Vwb2xpYS5nLmFsY2hlbXkuY29tL3YyL0FSRERxMHpZVGtYU1lqRlpJclhwTXotam9xMDd4S09vJyk7XHJcbiAgICAgIGNvbnRyYWN0ID0gZmV0Y2hDb250cmFjdChwcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udHJhY3Q7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgY29ubmVjdGluZyB3aXRoIGNvbnRyYWN0XCIsIGVycm9yKTtcclxuICAgIC8vIE7hur91IGPDsyBs4buXaSwga2jhu59pIHThuqFvIGNvbnRyYWN0IHbhu5tpIHByb3ZpZGVyIGtow7RuZyDEkcSDbmcgbmjhuq1wXHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKCdodHRwczovL2V0aC1zZXBvbGlhLmcuYWxjaGVteS5jb20vdjIvQVJERHEwellUa1hTWWpGWklyWHBNei1qb3EwN3hLT28nKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gZmV0Y2hDb250cmFjdChwcm92aWRlcik7XHJcbiAgICByZXR1cm4gY29udHJhY3Q7XHJcbiAgfVxyXG59O1xyXG5leHBvcnQgY29uc3QgTkZUTWFya2V0cGxhY2VDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xyXG5cclxuZXhwb3J0IGNvbnN0IE5GVE1hcmtldHBsYWNlUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgY29uc3QgdGl0bGVEYXRhID0gXCJEaXNjb3ZlciwgY29sbGVjdCwgYW5kIHNlbGwgTkZUc1wiO1xyXG5cclxuICAvLy0tLS0tLVVTRVNUQVRcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gIGNvbnN0IFtvcGVuRXJyb3IsIHNldE9wZW5FcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2N1cnJlbnRBY2NvdW50LCBzZXRDdXJyZW50QWNjb3VudF0gPSB1c2VTdGF0ZShcIlwiKTtcclxuICBjb25zdCBbYWNjb3VudEJhbGFuY2UsIHNldEFjY291bnRCYWxhbmNlXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG5cclxuICAvLy0tLUNIRUNLIElGIFdBTExFVCBJUyBDT05ORUNURFxyXG5cclxuICBjb25zdCBjaGVja0lmV2FsbGV0Q29ubmVjdGVkID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pXHJcbiAgICAgICAgcmV0dXJuIHNldE9wZW5FcnJvcih0cnVlKSwgc2V0RXJyb3IoXCJJbnN0YWxsIE1ldGFNYXNrXCIpO1xyXG5cclxuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7XHJcbiAgICAgICAgbWV0aG9kOiBcImV0aF9hY2NvdW50c1wiLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChhY2NvdW50cy5sZW5ndGgpIHtcclxuICAgICAgICBzZXRDdXJyZW50QWNjb3VudChhY2NvdW50c1swXSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYWNjb3VudHNbMF0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHNldEVycm9yKFwiTm8gQWNjb3VudCBGb3VuZFwiKTtcclxuICAgICAgICAvLyBzZXRPcGVuRXJyb3IodHJ1ZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJObyBhY2NvdW50XCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSk7XHJcbiAgICAgIGNvbnN0IGdldEJhbGFuY2UgPSBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKGFjY291bnRzWzBdKTtcclxuICAgICAgY29uc3QgYmFsID0gZXRoZXJzLmZvcm1hdEV0aGVyKGdldEJhbGFuY2UpO1xyXG4gICAgICBzZXRBY2NvdW50QmFsYW5jZShiYWwpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgLy8gc2V0RXJyb3IoXCJTb21ldGhpbmcgd3Jvbmcgd2hpbGUgY29ubmVjdGluZyB0byB3YWxsZXRcIik7XHJcbiAgICAgIC8vIHNldE9wZW5FcnJvcih0cnVlKTtcclxuICAgICAgY29uc29sZS5sb2coXCJub3QgY29ubmVjdGVkXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjaGVja0lmV2FsbGV0Q29ubmVjdGVkKCk7XHJcbiAgfSwgW10pO1xyXG4gIGNvbnN0IGFwcHJvdmVBbGxORlRzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY29udHJhY3QgPSBhd2FpdCBjb25uZWN0aW5nV2l0aFNtYXJ0Q29udHJhY3QoKTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNvbnRyYWN0LmZldGNoTXlORlRzKCk7XHJcbiAgXHJcbiAgICAgIC8vIEzhuqV5IGRhbmggc8OhY2ggdG9rZW5JZFxyXG4gICAgICBjb25zdCB0b2tlbklkcyA9IGRhdGEubWFwKChuZnQpID0+IG5mdC50b2tlbklkLnRvU3RyaW5nKCkpO1xyXG4gIFxyXG4gICAgICAvLyBBcHByb3ZlIHThu6tuZyBORlRcclxuICAgICAgZm9yIChjb25zdCB0b2tlbklkIG9mIHRva2VuSWRzKSB7XHJcbiAgICAgICAgY29uc3QgYXBwcm92YWxUeCA9IGF3YWl0IGNvbnRyYWN0LmFwcHJvdmUoY29udHJhY3QuYWRkcmVzcywgdG9rZW5JZCk7XHJcbiAgICAgICAgYXdhaXQgYXBwcm92YWxUeC53YWl0KCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0FwcHJvdmVkIE5GVCB3aXRoIHRva2VuIElEICR7dG9rZW5JZH0nKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYXBwcm92aW5nIE5GVHM6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgLy8tLS1DT05ORVQgV0FMTEVUIEZVTkNUSU9OXHJcbiAgY29uc3QgY29ubmVjdFdhbGxldCA9IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICghd2luZG93LmV0aGVyZXVtKVxyXG4gICAgICAgIHJldHVybiBzZXRPcGVuRXJyb3IodHJ1ZSksIHNldEVycm9yKFwiSW5zdGFsbCBNZXRhTWFza1wiKTtcclxuXHJcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgd2luZG93LmV0aGVyZXVtLnJlcXVlc3Qoe1xyXG4gICAgICAgIG1ldGhvZDogXCJldGhfcmVxdWVzdEFjY291bnRzXCIsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coYWNjb3VudHMpO1xyXG4gICAgICBzZXRDdXJyZW50QWNjb3VudChhY2NvdW50c1swXSk7XHJcblxyXG4gICAgICAvLyB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgIGNvbm5lY3RpbmdXaXRoU21hcnRDb250cmFjdCgpO1xyXG4gICAgICBhd2FpdCBhcHByb3ZlQWxsTkZUcygpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgLy8gc2V0RXJyb3IoXCJFcnJvciB3aGlsZSBjb25uZWN0aW5nIHRvIHdhbGxldFwiKTtcclxuICAgICAgLy8gc2V0T3BlbkVycm9yKHRydWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vLS0tVVBMT0FEIFRPIElQRlMgRlVOQ1RJT05cclxuICBjb25zdCB1cGxvYWRUb1BpbmF0YSA9IGFzeW5jIChmaWxlKSA9PiB7XHJcbiAgICBpZiAoZmlsZSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcyh7XHJcbiAgICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxyXG4gICAgICAgICAgdXJsOiBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZC9waW5uaW5nL3BpbkZpbGVUb0lQRlNcIixcclxuICAgICAgICAgIGRhdGE6IGZvcm1EYXRhLFxyXG4gICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICBwaW5hdGFfYXBpX2tleTogYGQyYzc3YTA4ZjhkZTc2NjYzMmQwYCxcclxuICAgICAgICAgICAgcGluYXRhX3NlY3JldF9hcGlfa2V5OiBgXHJcbiAgICAgICAgICAgIDk1NDZjYjY5YTg2MzQyMjlkOTVlNzUwZTUyNmZlZGQxNGVlYjdjODg1NmMxMmUwYWU5YzRiMWJkMGU1Njc0NGVgLFxyXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgSW1nSGFzaCA9IGBodHRwczovL2dhdGV3YXkucGluYXRhLmNsb3VkL2lwZnMvJHtyZXNwb25zZS5kYXRhLklwZnNIYXNofWA7XHJcblxyXG4gICAgICAgIHJldHVybiBJbWdIYXNoO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5hYmxlIHRvIHVwbG9hZCBpbWFnZSB0byBQaW5hdGFcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLy0tLUNSRUFURU5GVCBGVU5DVElPTlxyXG4gIGNvbnN0IGNyZWF0ZU5GVCA9IGFzeW5jIChuYW1lLCBwcmljZSwgaW1hZ2UsIGRlc2NyaXB0aW9uLCByb3V0ZXIpID0+IHtcclxuICAgIGlmICghbmFtZSB8fCAhZGVzY3JpcHRpb24gfHwgIXByaWNlIHx8ICFpbWFnZSlcclxuICAgICAgcmV0dXJuIHNldEVycm9yKFwiRGF0YSBJcyBNaXNzaW5nXCIpLCBzZXRPcGVuRXJyb3IodHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHsgbmFtZSwgZGVzY3JpcHRpb24sIGltYWdlIH0pO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3Moe1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZC9waW5uaW5nL3BpbkpTT05Ub0lQRlNcIixcclxuICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgIHBpbmF0YV9hcGlfa2V5OiBgZDJjNzdhMDhmOGRlNzY2NjMyZDBgLFxyXG4gICAgICAgICAgcGluYXRhX3NlY3JldF9hcGlfa2V5OiBgXHJcbiAgICAgICAgICA5NTQ2Y2I2OWE4NjM0MjI5ZDk1ZTc1MGU1MjZmZWRkMTRlZWI3Yzg4NTZjMTJlMGFlOWM0YjFiZDBlNTY3NDRlYCxcclxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vZ2F0ZXdheS5waW5hdGEuY2xvdWQvaXBmcy8ke3Jlc3BvbnNlLmRhdGEuSXBmc0hhc2h9YDtcclxuICAgICAgY29uc29sZS5sb2codXJsKTtcclxuXHJcbiAgICAgIGF3YWl0IGNyZWF0ZVNhbGUodXJsLCBwcmljZSk7XHJcbiAgICAgIHJvdXRlci5wdXNoKFwiL3NlYXJjaFBhZ2VcIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBzZXRFcnJvcihcIkVycm9yIHdoaWxlIGNyZWF0aW5nIE5GVFwiKTtcclxuICAgICAgc2V0T3BlbkVycm9yKHRydWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vLS0tIGNyZWF0ZVNhbGUgRlVOQ1RJT05cclxuICBjb25zdCBjcmVhdGVTYWxlID0gYXN5bmMgKHVybCwgZm9ybUlucHV0UHJpY2UsIGlzUmVzZWxsaW5nLCBpZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2codXJsLCBmb3JtSW5wdXRQcmljZSwgaXNSZXNlbGxpbmcsIGlkKTtcclxuICAgICAgY29uc3QgcHJpY2UgPSBldGhlcnMucGFyc2VVbml0cyhmb3JtSW5wdXRQcmljZSwgXCJldGhlclwiKTtcclxuXHJcbiAgICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgY29ubmVjdGluZ1dpdGhTbWFydENvbnRyYWN0KCk7XHJcblxyXG4gICAgICBjb25zdCBsaXN0aW5nUHJpY2UgPSBhd2FpdCBjb250cmFjdC5nZXRMaXN0aW5nUHJpY2UoKTtcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gIWlzUmVzZWxsaW5nXHJcbiAgICAgICAgPyBhd2FpdCBjb250cmFjdC5jcmVhdGVUb2tlbih1cmwsIHByaWNlLCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBsaXN0aW5nUHJpY2UudG9TdHJpbmcoKSxcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgOiBhd2FpdCBjb250cmFjdC5yZXNlbGxUb2tlbihpZCwgcHJpY2UsIHtcclxuICAgICAgICAgICAgdmFsdWU6IGxpc3RpbmdQcmljZS50b1N0cmluZygpLFxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICBhd2FpdCB0cmFuc2FjdGlvbi53YWl0KCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKHRyYW5zYWN0aW9uKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHNldEVycm9yKFwiZXJyb3Igd2hpbGUgY3JlYXRpbmcgc2FsZVwiKTtcclxuICAgICAgc2V0T3BlbkVycm9yKHRydWUpO1xyXG4gICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8tLUZFVENITkZUUyBGVU5DVElPTlxyXG5cclxuICBjb25zdCBmZXRjaE5GVHMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB3ZWIzTW9kYWwgPSBuZXcgV2ViM01vZGFsKCk7XHJcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB3ZWIzTW9kYWwuY29ubmVjdCgpO1xyXG4gICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKGNvbm5lY3Rpb24pO1xyXG5cclxuICAgICAgY29uc3QgY29udHJhY3QgPSBmZXRjaENvbnRyYWN0KHByb3ZpZGVyKTtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjb250cmFjdC5mZXRjaE1hcmtldEl0ZW1zKCk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhkYXRhKTtcclxuXHJcbiAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgICAgZGF0YS5tYXAoXHJcbiAgICAgICAgICBhc3luYyAoeyB0b2tlbklkLCBzZWxsZXIsIG93bmVyLCBwcmljZTogdW5mb3JtYXR0ZWRQcmljZSB9KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbklkID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgLy8gQuG7jyBxdWEgdG9rZW5JZCBraMO0bmcgaOG7o3AgbOG7h1xyXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuVVJJID0gYXdhaXQgY29udHJhY3QudG9rZW5VUkkodG9rZW5JZCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgICAgZGF0YTogeyBpbWFnZSwgbmFtZSwgZGVzY3JpcHRpb24gfSxcclxuICAgICAgICAgICAgfSA9IGF3YWl0IGF4aW9zLmdldCh0b2tlblVSSSwge30pO1xyXG4gICAgICAgICAgICBjb25zdCBwcmljZSA9IGV0aGVycy5mb3JtYXRVbml0cyhcclxuICAgICAgICAgICAgICB1bmZvcm1hdHRlZFByaWNlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgXCJldGhlclwiXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIHByaWNlLFxyXG4gICAgICAgICAgICAgIHRva2VuSWQ6IHRva2VuSWQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICBzZWxsZXIsXHJcbiAgICAgICAgICAgICAgb3duZXIsXHJcbiAgICAgICAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICB0b2tlblVSSSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBpdGVtcztcclxuXHJcbiAgICAgIC8vIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIC8vIHNldEVycm9yKFwiRXJyb3Igd2hpbGUgZmV0Y2hpbmcgTkZUU1wiKTtcclxuICAgICAgLy8gc2V0T3BlbkVycm9yKHRydWUpO1xyXG4gICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGZldGNoTkZUcygpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8tLUZFVENISU5HIE1ZIE5GVCBPUiBMSVNURUQgTkZUc1xyXG4gIGNvbnN0IGZldGNoTXlORlRzT3JMaXN0ZWRORlRzID0gYXN5bmMgKHR5cGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChjdXJyZW50QWNjb3VudCkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgY29ubmVjdGluZ1dpdGhTbWFydENvbnRyYWN0KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPVxyXG4gICAgICAgICAgdHlwZSA9PSBcImZldGNoSXRlbXNMaXN0ZWRcIlxyXG4gICAgICAgICAgICA/IGF3YWl0IGNvbnRyYWN0LmZldGNoSXRlbXNMaXN0ZWQoKVxyXG4gICAgICAgICAgICA6IGF3YWl0IGNvbnRyYWN0LmZldGNoTXlORlRzKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgICAgICBkYXRhLm1hcChcclxuICAgICAgICAgICAgYXN5bmMgKHsgdG9rZW5JZCwgc2VsbGVyLCBvd25lciwgcHJpY2U6IHVuZm9ybWF0dGVkUHJpY2UgfSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRva2VuVVJJID0gYXdhaXQgY29udHJhY3QudG9rZW5VUkkodG9rZW5JZCk7XHJcbiAgICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgZGF0YTogeyBpbWFnZSwgbmFtZSwgZGVzY3JpcHRpb24gfSxcclxuICAgICAgICAgICAgICB9ID0gYXdhaXQgYXhpb3MuZ2V0KHRva2VuVVJJKTtcclxuICAgICAgICAgICAgICBjb25zdCBwcmljZSA9IGV0aGVycy5mb3JtYXRVbml0cyhcclxuICAgICAgICAgICAgICAgIHVuZm9ybWF0dGVkUHJpY2UudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIFwiZXRoZXJcIlxyXG4gICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBwcmljZSxcclxuICAgICAgICAgICAgICAgIHRva2VuSWQ6IHRva2VuSWQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIHNlbGxlcixcclxuICAgICAgICAgICAgICAgIG93bmVyLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgICB0b2tlblVSSSxcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgLy8gc2V0RXJyb3IoXCJFcnJvciB3aGlsZSBmZXRjaGluZyBsaXN0ZWQgTkZUc1wiKTtcclxuICAgICAgLy8gc2V0T3BlbkVycm9yKHRydWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBmZXRjaE15TkZUc09yTGlzdGVkTkZUcygpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8tLS1idXkgTkZUXHJcbiAgY29uc3QgYnV5TkZUID0gYXN5bmMgKG5mdCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY29udHJhY3QgPSBhd2FpdCBjb25uZWN0aW5nV2l0aFNtYXJ0Q29udHJhY3QoKTtcclxuICAgICAgY29uc3QgcHJpY2UgPSBldGhlcnMucGFyc2VVbml0cyhuZnQucHJpY2UudG9TdHJpbmcoKSwgXCJldGhlclwiKTtcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgY29udHJhY3QuY3JlYXRlTWFya2V0U2FsZShuZnQudG9rZW5JZCwge1xyXG4gICAgICAgIHZhbHVlOiBwcmljZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBhd2FpdCB0cmFuc2FjdGlvbi53YWl0KCk7XHJcbiAgICAgIHJvdXRlci5wdXNoKFwiL2F1dGhvclwiKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHNldEVycm9yKFwiRXJyb3IgV2hpbGUgYnV5aW5nIE5GVFwiKTtcclxuICAgICAgc2V0T3BlbkVycm9yKHRydWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIERlbGV0ZSBORlRcclxuY29uc3QgYnVybk5GVCA9IGFzeW5jICh0b2tlbklkKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgY29ubmVjdGluZ1dpdGhTbWFydENvbnRyYWN0KCk7XHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmJ1cm5ORlQodG9rZW5JZCk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcbiAgICByb3V0ZXIucHVzaChcIi9hdXRob3JcIik7XHJcbiAgICBjb25zb2xlLmxvZyhcIk5GVCBidXJuZWQgc3VjY2Vzc2Z1bGx5XCIpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYnVybmluZyBORlQ6XCIsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBjYW5jZWwgU2FsZSBORlRcclxuY29uc3QgY2FuY2VsU2FsZSA9IGFzeW5jICh0b2tlbklkKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgY29ubmVjdGluZ1dpdGhTbWFydENvbnRyYWN0KCk7XHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmNhbmNlbFNhbGUodG9rZW5JZCk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcbiAgICByb3V0ZXIucHVzaChcIi9hdXRob3JcIik7XHJcbiAgICBjb25zb2xlLmxvZyhcIk5GVCBzYWxlIGNhbmNlbGVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhbmNlbGluZyBORlQgc2FsZTpcIiwgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuY29uc3QgZ2V0U2lnbmVyID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB3ZWIzTW9kYWwgPSBuZXcgV2ViM01vZGFsKCk7XHJcbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgd2ViM01vZGFsLmNvbm5lY3QoKTtcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIoY29ubmVjdGlvbik7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIHJldHVybiBzaWduZXI7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIHNpZ25lcjpcIiwgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5jb25zdCB0cmFuc2Zlck5GVCA9IGFzeW5jICh0b2tlbklkLCBhZGRyZXNzKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKFwiVHJhbmZlciB0bzogXCIsdG9rZW5JZCwgYWRkcmVzcyk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGNvbm5lY3RpbmdXaXRoU21hcnRDb250cmFjdCgpO1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XHJcblxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5jb25uZWN0KHNpZ25lcilbXCJ0cmFuc2ZlckZyb20oYWRkcmVzcyxhZGRyZXNzLHVpbnQyNTYpXCJdKGN1cnJlbnRBY2NvdW50LCBhZGRyZXNzLCB0b2tlbklkKTtcclxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSAxKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiTkZUIHRyYW5zZmVycmVkIHN1Y2Nlc3NmdWxseSFcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiVHJhbnNhY3Rpb24gZmFpbGVkIHdpdGggZXJyb3I6XCIsIHJlY2VpcHQuc3RhdHVzKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHRyYW5zZmVycmluZyBORlQ6XCIsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8TkZUTWFya2V0cGxhY2VDb250ZXh0LlByb3ZpZGVyXHJcbiAgICAgIHZhbHVlPXt7XHJcbiAgICAgICAgdXBsb2FkVG9QaW5hdGEsXHJcbiAgICAgICAgY2hlY2tJZldhbGxldENvbm5lY3RlZCxcclxuICAgICAgICBjb25uZWN0V2FsbGV0LFxyXG4gICAgICAgIGNyZWF0ZU5GVCxcclxuICAgICAgICBmZXRjaE5GVHMsXHJcbiAgICAgICAgZmV0Y2hNeU5GVHNPckxpc3RlZE5GVHMsXHJcbiAgICAgICAgYnV5TkZULFxyXG4gICAgICAgIGJ1cm5ORlQsXHJcbiAgICAgICAgY2FuY2VsU2FsZSxcclxuICAgICAgICBjcmVhdGVTYWxlLFxyXG4gICAgICAgIHRyYW5zZmVyTkZULFxyXG4gICAgICAgIGN1cnJlbnRBY2NvdW50LFxyXG4gICAgICAgIHRpdGxlRGF0YSxcclxuICAgICAgICBzZXRPcGVuRXJyb3IsXHJcbiAgICAgICAgb3BlbkVycm9yLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIGFjY291bnRCYWxhbmNlLFxyXG4gICAgICB9fVxyXG4gICAgPlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L05GVE1hcmtldHBsYWNlQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59OyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiV2ViM01vZGFsIiwiZXRoZXJzIiwidXNlUm91dGVyIiwiYXhpb3MiLCJORlRNYXJrZXRwbGFjZUFkZHJlc3MiLCJORlRNYXJrZXRwbGFjZUFCSSIsInRyYW5zZmVyRnVuZHNBZGRyZXNzIiwidHJhbnNmZXJGdW5kc0FCSSIsImZldGNoQ29udHJhY3QiLCJzaWduZXJPclByb3ZpZGVyIiwiQ29udHJhY3QiLCJjb25uZWN0aW5nV2l0aFNtYXJ0Q29udHJhY3QiLCJjb250cmFjdCIsIndpbmRvdyIsImV0aGVyZXVtIiwid2ViM01vZGFsIiwiY29ubmVjdGlvbiIsImNvbm5lY3QiLCJwcm92aWRlciIsIkJyb3dzZXJQcm92aWRlciIsInNpZ25lciIsImdldFNpZ25lciIsIkpzb25ScGNQcm92aWRlciIsImVycm9yIiwiY29uc29sZSIsImxvZyIsIk5GVE1hcmtldHBsYWNlQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJORlRNYXJrZXRwbGFjZVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ0aXRsZURhdGEiLCJzZXRFcnJvciIsIm9wZW5FcnJvciIsInNldE9wZW5FcnJvciIsImN1cnJlbnRBY2NvdW50Iiwic2V0Q3VycmVudEFjY291bnQiLCJhY2NvdW50QmFsYW5jZSIsInNldEFjY291bnRCYWxhbmNlIiwicm91dGVyIiwiY2hlY2tJZldhbGxldENvbm5lY3RlZCIsImFjY291bnRzIiwicmVxdWVzdCIsIm1ldGhvZCIsImxlbmd0aCIsImdldEJhbGFuY2UiLCJiYWwiLCJmb3JtYXRFdGhlciIsImFwcHJvdmVBbGxORlRzIiwiZGF0YSIsImZldGNoTXlORlRzIiwidG9rZW5JZHMiLCJtYXAiLCJuZnQiLCJ0b2tlbklkIiwidG9TdHJpbmciLCJhcHByb3ZhbFR4IiwiYXBwcm92ZSIsImFkZHJlc3MiLCJ3YWl0IiwiY29ubmVjdFdhbGxldCIsInVwbG9hZFRvUGluYXRhIiwiZmlsZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJyZXNwb25zZSIsInVybCIsImhlYWRlcnMiLCJwaW5hdGFfYXBpX2tleSIsInBpbmF0YV9zZWNyZXRfYXBpX2tleSIsIkltZ0hhc2giLCJJcGZzSGFzaCIsImNyZWF0ZU5GVCIsIm5hbWUiLCJwcmljZSIsImltYWdlIiwiZGVzY3JpcHRpb24iLCJKU09OIiwic3RyaW5naWZ5IiwiY3JlYXRlU2FsZSIsInB1c2giLCJmb3JtSW5wdXRQcmljZSIsImlzUmVzZWxsaW5nIiwiaWQiLCJwYXJzZVVuaXRzIiwibGlzdGluZ1ByaWNlIiwiZ2V0TGlzdGluZ1ByaWNlIiwidHJhbnNhY3Rpb24iLCJjcmVhdGVUb2tlbiIsInZhbHVlIiwicmVzZWxsVG9rZW4iLCJmZXRjaE5GVHMiLCJmZXRjaE1hcmtldEl0ZW1zIiwiaXRlbXMiLCJQcm9taXNlIiwiYWxsIiwic2VsbGVyIiwib3duZXIiLCJ1bmZvcm1hdHRlZFByaWNlIiwidG9rZW5VUkkiLCJnZXQiLCJmb3JtYXRVbml0cyIsImZldGNoTXlORlRzT3JMaXN0ZWRORlRzIiwidHlwZSIsImZldGNoSXRlbXNMaXN0ZWQiLCJidXlORlQiLCJjcmVhdGVNYXJrZXRTYWxlIiwiYnVybk5GVCIsInR4IiwiY2FuY2VsU2FsZSIsInRyYW5zZmVyTkZUIiwicmVjZWlwdCIsInN0YXR1cyIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./Context/NFTMarketplaceContext.js\n"));

/***/ })

});